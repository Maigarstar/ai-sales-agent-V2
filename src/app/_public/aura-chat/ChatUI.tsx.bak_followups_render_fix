"use client";

import React, { useEffect, useMemo, useRef, useState } from "react";
import { useSearchParams } from "next/navigation";
import {
  Send,
  Trash2,
  X,
  Sparkles,
  Menu,
  Plus,
  Search,
  MessageSquare,
  PanelLeftClose,
  PanelLeftOpen,
} from "lucide-react";
import AuraVoice from "@/app/components/AuraVoice";
import VoiceToTextButton from "@/app/components/VoiceToTextButton";

/* =========================================================
   Storage keys
========================================================= */
const STORAGE_KEY_COOKIE = "fsw_cookie_consent";
const STORAGE_KEY_SESSIONS = "fsw_chat_sessions_v3";
const STORAGE_KEY_CHAT_ACTIVE = "fsw_chat_active_v3";
const STORAGE_KEY_LEAD = "fsw_lead_v3";
const STORAGE_KEY_CONV_PREFIX = "fsw_chat_conv_v3_";
const STORAGE_KEY_ACTIVE_THREAD = "fsw_active_thread_id_v1";

/* =========================================================
   Branding
========================================================= */
const BRAND = "Taigenic";
const PRODUCT = "Concierge";
const ASSISTANT = "Aura";
const DIRECTORY_DOMAIN = "5starweddingdirectory.com";

/* =========================================================
   Opening message
========================================================= */
const OPENING_MESSAGE = `
Hello, I’m Aura, the concierge for 5 Star Weddings.

I help couples discover exceptional wedding venues and trusted vendors,
and I help wedding businesses attract the right clients and grow visibility.

Tell me what brings you here today.
`.trim();

/* =========================================================
   Starter chips
========================================================= */
const COUPLE_PROMPTS = [
  "We want Lake Como, around 80 guests",
  "Budget breakdown for 100 guests",
  "12 month planning timeline",
  "Suggest a jazz band in London",
  "Spring floral styling ideas",
];

const VENDOR_PROMPTS = [
  "How can I improve my SEO?",
  "How do I attract destination couples?",
  "Help me position my venue for luxury weddings",
  "Write a premium website intro for my business",
  "What should I charge, and how do I sell it?",
];

/* =========================================================
   Types
========================================================= */
type ChatMessage = { role: "user" | "assistant"; content: string; suggestions?: string[] };

type Intent = "couple" | "vendor" | "unknown";

type Lead = {
  name: string;
  email: string;
  capturedAt: number;
  dismissed?: boolean;
};

type SidebarSession = {
  conversationId: string;
  title: string;
  updatedAt: number;
  lastMessage?: string;
  intent?: Intent;
};

type ThreadRow = {
  id: string;
  title?: string | null;
  chat_type?: string | null;
  created_at?: string | null;
  updated_at?: string | null;
};

function safeJsonParse<T>(raw: string | null, fallback: T): T {
  if (!raw) return fallback;
  try {
    return JSON.parse(raw) as T;
  } catch {
    return fallback;
  }
}

function nowTs() {
  return Date.now();
}

function clampMessages<T extends { role: string; content: string }>(msgs: T[], max = 80) {
  if (!Array.isArray(msgs)) return [];
  if (msgs.length <= max) return msgs;
  return msgs.slice(msgs.length - max);
}

function convStorageKey(conversationId: string) {
  return `${STORAGE_KEY_CONV_PREFIX}${conversationId}`;
}

function detectIntent(text: string): Intent {
  const m = (text || "").toLowerCase();

  const vendorSignals = [
    "seo",
    "enquiries",
    "inquiries",
    "marketing",
    "listing",
    "featured",
    "pricing",
    "packages",
    "venue owner",
    "wedding planner",
    "planner",
    "hotel",
    "resort",
    "bookings",
    "conversion",
    "leads",
    "website",
  ];

  const coupleSignals = [
    "guests",
    "guest",
    "budget",
    "wedding date",
    "date",
    "proposal",
    "honeymoon",
    "venues",
    "venue",
    "lake como",
    "tuscany",
    "amalfi",
    "italy",
    "ibiza",
    "france",
    "dress",
    "flowers",
  ];

  const vendorHit = vendorSignals.some((s) => m.includes(s));
  const coupleHit = coupleSignals.some((s) => m.includes(s));

  if (vendorHit && !coupleHit) return "vendor";
  if (coupleHit && !vendorHit) return "couple";
  return "unknown";
}

/* FOLLOWUPS_BEGIN */
function buildFollowUps(reply: string, intent: Intent): string[] {
  const r = String(reply || "").toLowerCase();

  const couple = [
    "Show me 3 venue ideas for this",
    "Give me a budget split for this",
    "Create a timeline checklist for this",
  ];

  const vendor = [
    "Rewrite my positioning in luxury tone",
    "Give me 5 SEO fixes to do today",
    "Create a premium package offer",
  ];

  const neutral = [
    "Ask me 3 questions to refine this",
    "Summarise options in 3 bullets",
    "What should we decide next",
  ];

  if (intent === "vendor") return vendor;

  if (intent === "couple") {
    if (r.includes("budget")) return ["Break down the budget in detail", "What vendors do we book first", "Create a 12 month plan"];
    if (r.includes("venue") || r.includes("venues")) return ["Compare 3 venues side by side", "What questions should we ask venues", "Suggest the best season for this"];
    return couple;
  }

  return neutral;
}
/* FOLLOWUPS_END */


/* =========================================================
   UUID helper
========================================================= */
function makeUuid() {
  if (typeof crypto !== "undefined" && "randomUUID" in crypto) {
    return crypto.randomUUID();
  }

  const s: string[] = [];
  const hex = "0123456789abcdef";
  for (let i = 0; i < 36; i++) s[i] = hex[Math.floor(Math.random() * 16)];
  s[14] = "4";
  s[19] = hex[(parseInt(s[19], 16) & 0x3) | 0x8];
  s[8] = s[13] = s[18] = s[23] = "-";
  return s.join("");
}

/* =========================================================
   Formatter
========================================================= */
function FormattedMessage({ content }: { content: string }) {
  const cleanContent = content.replace(/\\n/g, "\n");
  const lines = cleanContent.split("\n");

  return (
    <div className="space-y-2">
      {lines.map((line, i) => {
        const t = line.trim();
        if (!t) return <div key={i} className="h-1" />;

        const isH3 = t.startsWith("### ");
        const isH4 = t.startsWith("#### ");
        if (isH3) return <h3 key={i} className="text-lg font-semibold text-[#1F4D3E] mt-3">{t.substring(4)}</h3>;
        if (isH4) return <h4 key={i} className="text-md font-semibold text-gray-900 mt-2">{t.substring(5)}</h4>;

        const isBullet = t.startsWith("* ") || t.startsWith("- ");
        const isNumber = /^\d+\.\s/.test(t);

        let displayText = t;
        if (isBullet) displayText = t.substring(2);
        if (isNumber) displayText = t.replace(/^\d+\.\s/, "");

        const parts = displayText.split(/(\*\*.*?\*\*)/g).map((part, j) => {
          if (part.startsWith("**") && part.endsWith("**")) {
            return <strong key={j} className="font-semibold text-gray-900">{part.slice(2, -2)}</strong>;
          }
          return part;
        });

        if (isBullet || isNumber) {
          return (
            <div key={i} className="flex items-start">
              <span
                className={`mr-2 mt-1 flex-shrink-0 ${
                  isBullet ? "w-1.5 h-1.5 bg-gray-400 rounded-full mt-2" : "font-semibold text-[#1F4D3E] text-xs min-w-[18px]"
                }`}
              >
                {isNumber ? t.match(/^\d+/)?.[0] + "." : ""}
              </span>
              <span className="leading-relaxed text-gray-800">{parts}</span>
            </div>
          );
        }

        return <p key={i} className="leading-relaxed text-gray-800">{parts}</p>;
      })}
    </div>
  );
}

/* =========================================================
   Lead capture inline card
========================================================= */
function LeadCaptureInline({
  onSubmit,
  onSkip,
}: {
  onSubmit: (name: string, email: string) => void;
  onSkip: () => void;
}) {
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");

  return (
    <div className="border border-gray-200 rounded-xl p-4 bg-gray-50">
      <p className="text-sm text-gray-700 mb-3">
        Want me to save this conversation and send you tailored recommendations?
      </p>

      <div className="space-y-2">
        <input
          placeholder="Your name"
          value={name}
          onChange={(e) => setName(e.target.value)}
          className="w-full px-3 py-2 rounded-lg border border-gray-300 bg-white outline-none focus:ring-1 focus:ring-[#1F4D3E] focus:border-[#1F4D3E]"
        />
        <input
          placeholder="Email address"
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          className="w-full px-3 py-2 rounded-lg border border-gray-300 bg-white outline-none focus:ring-1 focus:ring-[#1F4D3E] focus:border-[#1F4D3E]"
        />
      </div>

      <div className="flex items-center gap-3 mt-3">
        <button
          type="button"
          onClick={() => onSubmit(name.trim(), email.trim())}
          className="px-4 py-2 bg-[#1F4D3E] text-white rounded-lg text-sm font-medium hover:bg-[#163C30]"
        >
          Save and continue
        </button>

        <button
          type="button"
          onClick={onSkip}
          className="text-sm text-gray-500 hover:underline"
        >
          Skip
        </button>
      </div>

      <p className="text-[11px] text-gray-500 mt-3">
        By submitting, you agree we may contact you about relevant wedding services and recommendations.
      </p>
    </div>
  );
}

/* =========================================================
   Cookie preferences
========================================================= */
function CookiePreferenceCenter({ isOpen, onClose }: { isOpen: boolean; onClose: () => void }) {
  const [analytics, setAnalytics] = useState(false);
  const [marketing, setMarketing] = useState(false);

  useEffect(() => {
    if (!isOpen) return;
    const saved = localStorage.getItem(STORAGE_KEY_COOKIE);
    if (saved) {
      const parsed = safeJsonParse<any>(saved, {});
      setAnalytics(!!parsed.analytics);
      setMarketing(!!parsed.marketing);
    }
  }, [isOpen]);

  const save = () => {
    localStorage.setItem(STORAGE_KEY_COOKIE, JSON.stringify({ analytics, marketing, timestamp: nowTs() }));
    onClose();
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-[9999] flex items-center justify-center p-4 bg-black/50">
      <div className="bg-white rounded-2xl shadow-2xl w-full max-w-[520px] overflow-hidden">
        <div className="p-5 border-b border-gray-100 flex items-center justify-between">
          <div className="text-base font-semibold text-gray-900">Cookie preferences</div>
          <button onClick={onClose} className="p-2 rounded-lg hover:bg-gray-100 text-gray-500">
            <X size={18} />
          </button>
        </div>

        <div className="p-5 space-y-4">
          <div className="flex items-center justify-between">
            <div>
              <div className="text-sm font-medium text-gray-900">Analytics</div>
              <div className="text-xs text-gray-500">Improve performance</div>
            </div>
            <input type="checkbox" checked={analytics} onChange={(e) => setAnalytics(e.target.checked)} />
          </div>

          <div className="flex items-center justify-between">
            <div>
              <div className="text-sm font-medium text-gray-900">Marketing</div>
              <div className="text-xs text-gray-500">Measure campaigns</div>
            </div>
            <input type="checkbox" checked={marketing} onChange={(e) => setMarketing(e.target.checked)} />
          </div>

          <div className="text-[11px] text-gray-500">
            Privacy policy at {DIRECTORY_DOMAIN}/privacy
          </div>
        </div>

        <div className="p-4 border-t border-gray-100 bg-gray-50 flex justify-end">
          <button
            onClick={save}
            className="px-5 py-2 bg-[#1F4D3E] text-white rounded-lg text-sm font-medium hover:bg-[#163C30]"
          >
            Save
          </button>
        </div>
      </div>
    </div>
  );
}

/* =========================================================
   Main component
========================================================= */
export default function VendorsChatInner() {
  const searchParams = useSearchParams();
  const isEmbed = searchParams.get("embed") === "1";
  const organisationId = searchParams.get("organisationId") || "9ecd45ab-6ed2-46fa-914b-82be313e06e4";
  const agentId = searchParams.get("agentId") || "70660422-489c-4b7d-81ae-b786e43050db";

  const [conversationId, setConversationId] = useState<string | null>(null);
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [input, setInput] = useState("");
  const [loading, setLoading] = useState(false);
  const [editingUserIndex, setEditingUserIndex] = useState<number>(-1);
  const [editDraft, setEditDraft] = useState<string>("");

  const [intent, setIntent] = useState<Intent>("unknown");

  const [sessions, setSessions] = useState<SidebarSession[]>([]);
  const [sessionQuery, setSessionQuery] = useState("");

  const [sidebarOpen, setSidebarOpen] = useState(false);

  const [lead, setLead] = useState<Lead | null>(null);
  const [leadShownOnce, setLeadShownOnce] = useState(false);

  const [isCookieModalOpen, setIsCookieModalOpen] = useState(false);
  const [copied, setCopied] = useState(false);

  const [activeThreadId, setActiveThreadId] = useState<string>("");

  /* AUTO_TITLE_SAFE_BEGIN */
  const titledThreadIdsRef = useRef<Set<string>>(new Set());

  function makeThreadTitleFromText(text: string) {
    const clean = String(text || "")
      .replace(/\s+/g, " ")
      .replace(/[\`"'“”]/g, "")
      .trim();

    if (!clean) return "Conversation";

    const max = 64;
    return clean.length <= max ? clean : clean.slice(0, max).trim() + "…";
  }

  async function maybeAutoTitleThread(threadId: string, firstUserText: string) {
    const id = String(threadId || "").trim();
    if (!id) return;

    if (titledThreadIdsRef.current.has(id)) return;
    titledThreadIdsRef.current.add(id);

    const title = makeThreadTitleFromText(firstUserText);

    try {
      const res = await fetch(`/api/threads/${id}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ title }),
      });

      if (res.ok) {
        const data = await res.json().catch(() => ({}));
      

        const savedTitle = String(data?.thread?.title || title);

        setThreads((prev: any) =>
          Array.isArray(prev)
            ? prev.map((t: any) => (t?.id === id ? { ...t, title: savedTitle } : t))
            : prev
        );
      }
    } catch {
      // ignore
    }
  }
  /* AUTO_TITLE_SAFE_END */

  const [serverMode, setServerMode] = useState(false);
  const [threads, setThreads] = useState<ThreadRow[]>([]);
  const [threadsLoading, setThreadsLoading] = useState(false);
  const [bootstrapped, setBootstrapped] = useState(false);

  const scrollRef = useRef<HTMLDivElement>(null);
  const textareaRef = useRef<HTMLTextAreaElement | null>(null);

  async function loadThread(threadId: string) {
    const id = String(threadId || "").trim();
    if (!id) return;

    setActiveThreadId(id);
    try {
      localStorage.setItem(STORAGE_KEY_ACTIVE_THREAD, id);
    } catch {}

    setConversationId(null);
    setIntent("unknown");
    setLeadShownOnce(false);

    try {
      const mRes = await fetch(`/api/threads/${id}/messages`, { method: "GET" });
      if (!mRes.ok) {
        setMessages([{ role: "assistant", content: OPENING_MESSAGE }]);
        return;
      }

      const mData = await mRes.json().catch(() => ({}));
      const msgs = Array.isArray(mData?.messages) ? mData.messages : [];

      if (!msgs.length) {
        setMessages([{ role: "assistant", content: OPENING_MESSAGE }]);
        return;
      }

      setMessages(
        msgs.map((m: any) => ({
          role: m?.role === "user" ? "user" : "assistant",
          content: String(m?.content || ""),
        }))
      );
    } catch {
      setMessages([{ role: "assistant", content: OPENING_MESSAGE }]);
    }
  }

  async function createThread(chatType: "couple" | "business") {
    try {
      const res = await fetch("/api/threads", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          chatType,
          title: "New conversation",
        }),
      });

      if (!res.ok) return "";
      const data = await res.json().catch(() => ({}));
      const id = String(data?.thread?.id || "").trim();
      return id;
    } catch {
      return "";
    }
  }

  async function refreshThreads(preferId?: string) {
    setThreadsLoading(true);
    try {
      const tRes = await fetch("/api/threads", { method: "GET" });
      if (!tRes.ok) {
        setServerMode(false);
        return;
      }

      const tData = await tRes.json().catch(() => ({}));
      const list = Array.isArray(tData?.threads) ? (tData.threads as ThreadRow[]) : [];
      setThreads(list);
      setServerMode(true);

      let wanted = String(preferId || "").trim();
      if (!wanted) {
        try {
          wanted = String(localStorage.getItem(STORAGE_KEY_ACTIVE_THREAD) || "").trim();
        } catch {
          wanted = "";
        }
      }

      const hasWanted = wanted && list.some((t) => t?.id === wanted);
      const first = String(list?.[0]?.id || "").trim();

      if (hasWanted) {
        await loadThread(wanted);
        return;
      }

      if (first) {
        await loadThread(first);
        return;
      }

      const newId = await createThread("couple");
      if (newId) {
        await refreshThreads(newId);
      }
    } finally {
      setThreadsLoading(false);
    }
  }


  
  /* Bootstrap, prefer server threads, else fall back to local storage */
  useEffect(() => {
    (async () => {
      try {
        await refreshThreads();
      } finally {
        setBootstrapped(true);
      }
    })();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  /* Restore lead */
  useEffect(() => {
    const l = safeJsonParse<Lead | null>(localStorage.getItem(STORAGE_KEY_LEAD), null);
    if (l?.email) setLead(l);
  }, []);

  /* Restore sessions, only used when server threads are not available */
  useEffect(() => {
    if (!bootstrapped) return;
    if (serverMode) return;
    const all = safeJsonParse<SidebarSession[]>(localStorage.getItem(STORAGE_KEY_SESSIONS), []);
    setSessions(all.sort((a, b) => b.updatedAt - a.updatedAt));
  }, [bootstrapped, serverMode]);

  /* Restore active local chat, only when server threads are not available */
  useEffect(() => {
    if (!bootstrapped) return;
    if (serverMode) return;

    const saved = safeJsonParse<any>(localStorage.getItem(STORAGE_KEY_CHAT_ACTIVE), null);
    if (saved?.conversationId && Array.isArray(saved?.messages)) {
      setConversationId(saved.conversationId);
      setMessages(saved.messages);
      setIntent(saved.intent || "unknown");
      return;
    }

    setConversationId(null);
    setMessages([{ role: "assistant", content: OPENING_MESSAGE }]);
    setIntent("unknown");
  }, [bootstrapped, serverMode]);

  /* Cookie prompt */
  useEffect(() => {
    if (isEmbed) return;
    const raw = localStorage.getItem(STORAGE_KEY_COOKIE);
    if (!raw) setIsCookieModalOpen(true);
  }, [isEmbed]);

  /* Scroll */
  useEffect(() => {
    if (scrollRef.current) scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
  }, [messages, loading]);

  /* Textarea autoresize */
  useEffect(() => {
    if (!textareaRef.current) return;
    textareaRef.current.style.height = "auto";
    textareaRef.current.style.height = `${Math.min(textareaRef.current.scrollHeight, 180)}px`;
  }, [input]);

  /* Persist active chat, local storage only when not in server mode */
  useEffect(() => {
    if (serverMode) return;
    if (!conversationId) return;

    const payload = {
      conversationId,
      messages: clampMessages(messages, 80),
      intent,
      timestamp: nowTs(),
    };

    localStorage.setItem(STORAGE_KEY_CHAT_ACTIVE, JSON.stringify(payload));
    localStorage.setItem(convStorageKey(conversationId), JSON.stringify(payload));

    const last = payload.messages[payload.messages.length - 1]?.content || "";
    const title = lead?.email ? (lead.name || lead.email) : "New chat";

    const current = safeJsonParse<SidebarSession[]>(localStorage.getItem(STORAGE_KEY_SESSIONS), []);
    const merged: SidebarSession = {
      conversationId,
      title,
      updatedAt: nowTs(),
      lastMessage: last.slice(0, 140),
      intent,
    };

    const next = [merged, ...current.filter((s) => s.conversationId !== conversationId)]
      .sort((a, b) => b.updatedAt - a.updatedAt);

    localStorage.setItem(STORAGE_KEY_SESSIONS, JSON.stringify(next));
    setSessions(next);
  }, [serverMode, conversationId, messages, intent, lead]);

  const filteredSessions = useMemo(() => {
    const q = sessionQuery.trim().toLowerCase();
    if (!q) return sessions;
    return sessions.filter(
      (s) =>
        (s.title || "").toLowerCase().includes(q) ||
        (s.lastMessage || "").toLowerCase().includes(q)
    );
  }, [sessions, sessionQuery]);

  const filteredThreads = useMemo(() => {
    const q = sessionQuery.trim().toLowerCase();
    if (!q) return threads;
    return threads.filter((t) => String(t?.title || "New conversation").toLowerCase().includes(q));
  }, [threads, sessionQuery]);

  async function startConversationIfNeeded(): Promise<string> {
    if (conversationId) return conversationId;

    const provisionalId = makeUuid();
    setConversationId(provisionalId);

    try {
      const res = await fetch("/api/chat/start", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          user_type: "public",
          contact_name: lead?.name || null,
          contact_email: lead?.email || null,
          contact_phone: null,
          venue_or_location: null,
          website: null,
          wedding_date: null,
          organisationId,
          agentId,
          conversationId: provisionalId,
          threadId: activeThreadId || null,
        }),
      });

      const data = await res.json().catch(() => ({}));
      if (data?.threadId) {
        setActiveThreadId(String(data.threadId));
        try {
          localStorage.setItem(STORAGE_KEY_ACTIVE_THREAD, String(data.threadId));
        } catch {}
      }

      if (data?.ok && data?.conversationId && typeof data.conversationId === "string") {
        if (data.conversationId !== provisionalId) setConversationId(data.conversationId);
        return data.conversationId;
      }

      return provisionalId;
    } catch {
      return provisionalId;
    }
  }

  async function startNewChat() {
    if (serverMode) {
      setInput("");
      setLoading(false);
      setSidebarOpen(false);

      const newId = await createThread("couple");
      if (newId) {
        await refreshThreads(newId);
        return;
      }

      setMessages([{ role: "assistant", content: OPENING_MESSAGE }]);
      setActiveThreadId("");
      setConversationId(null);
      setIntent("unknown");
      return;
    }

    localStorage.removeItem(STORAGE_KEY_CHAT_ACTIVE);
    setConversationId(null);
    setIntent("unknown");
    setInput("");
    setLoading(false);
    setSidebarOpen(false);
    setMessages([{ role: "assistant", content: OPENING_MESSAGE }]);
  }

  function openSession(id: string) {
    const stored = safeJsonParse<any>(localStorage.getItem(convStorageKey(id)), null);
    if (stored?.conversationId === id && Array.isArray(stored?.messages)) {
      setConversationId(id);
      setMessages(stored.messages);
      setIntent(stored.intent || "unknown");
      setSidebarOpen(false);
    }
  }

  function deleteSession(id: string) {
    const current = safeJsonParse<SidebarSession[]>(localStorage.getItem(STORAGE_KEY_SESSIONS), []);
    const next = current.filter((s) => s.conversationId !== id);
    localStorage.setItem(STORAGE_KEY_SESSIONS, JSON.stringify(next));
    setSessions(next);
    localStorage.removeItem(convStorageKey(id));

    if (conversationId === id) {
      localStorage.removeItem(STORAGE_KEY_CHAT_ACTIVE);
      setConversationId(null);
      setIntent("unknown");
      setInput("");
      setLoading(false);
      setSidebarOpen(false);
      setMessages([{ role: "assistant", content: OPENING_MESSAGE }]);
    }
  }

  async function handleSend(manual?: string) {
    const text = (manual ?? input).trim();
    if (!text) return;
    const nextIntent = intent === "unknown" ? detectIntent(text) : intent;
    if (nextIntent !== intent) setIntent(nextIntent);

    const userMsg: ChatMessage = { role: "user", content: text };
    const nextMessages = clampMessages([...messages, userMsg], 80);

    setMessages(nextMessages);
    if (!manual) setInput("");
    setLoading(true);

    
    const shouldAutoTitle = serverMode && messages.every((m) => m.role !== "user");
    let threadForTitle = activeThreadId;

    

    try {
      const chatType =
        nextIntent === "vendor" ? "vendor" : nextIntent === "couple" ? "couple" : "couple";

      const id = await startConversationIfNeeded();

      const res = await fetch("/api/vendors-chat", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          messages: nextMessages,
          chatType,
          conversationId: id,
          organisationId,
          agentId,
          threadId: activeThreadId || null,
        }),
      });

      const data = await res.json().catch(() => ({}));
      /* AUTO_TITLE_SAFE_CALL */
      const isFirstUserMessageInThisThread = !messages.some((m) => m.role === "user");
      const threadIdFromResponse = String(data?.threadId || "").trim();
      const effectiveThreadId = String(threadIdFromResponse || activeThreadId || "").trim();

      if (isFirstUserMessageInThisThread && effectiveThreadId) {
        void maybeAutoTitleThread(effectiveThreadId, text);
      }
      /* AUTO_TITLE_SAFE_CALL_END */

      const reply = String(data?.reply || "").trim();

      if (reply) {
        const assistantMsg: ChatMessage = { role: "assistant", content: reply, suggestions: buildFollowUps(reply, intent) };
        setMessages((prev) => clampMessages([...prev, assistantMsg], 80));
      } else {
        setMessages((prev) =>
          clampMessages([...prev, { role: "assistant", content: "I’m here. Say that again and I’ll answer properly." }], 80)
        );
      }

      if (serverMode && activeThreadId) {
        await refreshThreads(activeThreadId);
      }
    } catch {
      setMessages((prev) =>
        clampMessages(
          [...prev, { role: "assistant", content: "Network issue. Try again, and I’ll pick up where we left off." }],
          80
        )
      );
    } finally {
      setLoading(false);
    }
  }

  
  /* REGEN_EDIT_BEGIN */
  function beginEdit(index: number) {
    const m = (messages as any)[index];
    if (!m || m.role !== "user") return;
    setEditingUserIndex(index);
    setEditDraft(String(m.content || ""));
  }

  function cancelEdit() {
    setEditingUserIndex(-1);
    setEditDraft("");
  }

  async function runChatFrom(messagesForRun: any[], opts?: { regenerate?: boolean }) {
    const chatType = intent === "vendor" ? "vendor" : "couple";

    setLoading(true);

    try {
      const id = await startConversationIfNeeded();

      const res = await fetch("/api/vendors-chat", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          messages: messagesForRun,
          chatType,
          conversationId: id,
          organisationId,
          agentId,
          threadId: activeThreadId || null,
          regenerate: !!opts?.regenerate,
        }),
      });

      const data = await res.json().catch(() => ({}));
      const reply = String(data?.reply || "").trim();

      if (reply) {
        setMessages((prev: any) => [...messagesForRun, { role: "assistant", content: reply, suggestions: buildFollowUps(reply, intent) }]);
      } else {
        setMessages((prev: any) => [...messagesForRun, { role: "assistant", content: "I’m here. Say that again and I’ll answer properly." }]);
      }
    } catch {
      setMessages((prev: any) =>
        [...messagesForRun, { role: "assistant", content: "Network issue. Try again, and I’ll pick up where we left off." }]
      );
    } finally {
      setLoading(false);
    }
  }

  async function saveEdit(index: number) {
    const nextText = String(editDraft || "").trim();
    if (!nextText) return;

    const updated = (messages as any).map((m: any, i: number) =>
      i === index ? { ...m, content: nextText } : m
    );

    const truncated = updated.slice(0, index + 1);

    setMessages(truncated);
    setEditingUserIndex(-1);
    setEditDraft("");

    await runChatFrom(truncated, { regenerate: true });
  }

  async function handleRegenerate() {
    if (loading) return;

    const la = lastAssistantIndex;
    if (la < 0) return;

    const trimmed = (messages as any).slice(0, la);

    if (trimmed.length === 0) return;

    setMessages(trimmed);

    await runChatFrom(trimmed, { regenerate: true });
  }
  /* REGEN_EDIT_END */

  function handleKeyDown(e: React.KeyboardEvent) {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  }

  function handleEndChat() {
    if (!confirm("End this chat and start fresh?")) return;
    startNewChat();
  }

  const assistantCount = useMemo(
    () => messages.filter((m) => m.role === "assistant").length,
    [messages]
  );

  /* REGEN_EDIT_MEMO_BEGIN */
  const lastUserIndex = useMemo(() => {
    for (let i = messages.length - 1; i >= 0; i--) {
      if ((messages as any)[i]?.role === "user") return i;
    }
    return -1;
  }, [messages]);

  const lastAssistantIndex = useMemo(() => {
    for (let i = messages.length - 1; i >= 0; i--) {
      if ((messages as any)[i]?.role === "assistant") return i;
    }
    return -1;
  }, [messages]);
  /* REGEN_EDIT_MEMO_END */

  const shouldShowLeadCard =
    !lead?.email &&
    !lead?.dismissed &&
    assistantCount >= 2 &&
    !loading &&
    !leadShownOnce;

  function captureLead(name: string, email: string) {
    if (!email) return;

    const l: Lead = { name: name || "Guest", email, capturedAt: nowTs() };
    setLead(l);
    localStorage.setItem(STORAGE_KEY_LEAD, JSON.stringify(l));

    fetch("/api/leads/capture", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        name: l.name,
        email: l.email,
        conversationId,
        intent,
        source: "taigenic_concierge",
        threadId: activeThreadId || null,
      }),
    }).catch(() => {});

    setLeadShownOnce(true);

    setMessages((prev) =>
      clampMessages(
        [
          ...prev,
          { role: "assistant", content: `Perfect, saved as ${email}. What would you like next?` },
        ],
        80
      )
    );
  }

  function skipLead() {
    const l: Lead = { name: "", email: "", capturedAt: nowTs(), dismissed: true };
    localStorage.setItem(STORAGE_KEY_LEAD, JSON.stringify(l));
    setLead(l);
    setLeadShownOnce(true);
  }

  const quickPrompts = useMemo(() => {
    if (intent === "vendor") return VENDOR_PROMPTS;
    if (intent === "couple") return COUPLE_PROMPTS;
    return COUPLE_PROMPTS;
  }, [intent]);

  async function copyDirectory() {
    try {
      await navigator.clipboard.writeText(DIRECTORY_DOMAIN);
      setCopied(true);
      setTimeout(() => setCopied(false), 1500);
    } catch {
      // ignore
    }
  }

  const SidebarContent = (
    <div className="h-full flex flex-col">
      <div className="p-4 border-b border-gray-100 bg-white">
        <div className="flex items-start justify-between gap-3">
          <div className="leading-tight">
            <div className="text-[13px] text-gray-500">{BRAND}</div>
            <div className="text-[15px] font-semibold text-gray-900">{PRODUCT}</div>
            <div className="text-[11px] text-gray-400 mt-1">
              Chat persona: {ASSISTANT}
            </div>
            {serverMode ? (
              <div className="text-[11px] text-gray-500 mt-1">
                Threads enabled
              </div>
            ) : (
              <div className="text-[11px] text-gray-500 mt-1">
                Local history mode
              </div>
            )}
          </div>

          <button
            type="button"
            onClick={() => setSidebarOpen(false)}
            className="hidden md:inline-flex p-2 rounded-xl border border-gray-200 bg-white hover:bg-gray-50"
            title="Close sidebar"
          >
            <PanelLeftClose size={18} className="text-gray-700" />
          </button>
        </div>

        <div className="mt-3 flex items-center gap-2">
          <button
            type="button"
            onClick={startNewChat}
            className="flex-1 inline-flex items-center justify-center gap-2 px-3 py-2 rounded-lg bg-[#1F4D3E] text-white text-sm font-medium hover:bg-[#163C30]"
          >
            <Plus size={16} /> New chat
          </button>
        </div>

        <div className="mt-3 flex items-center gap-2">
          <div className="flex-1 relative">
            <Search size={16} className="absolute left-3 top-2.5 text-gray-400" />
            <input
              value={sessionQuery}
              onChange={(e) => setSessionQuery(e.target.value)}
              placeholder={serverMode ? "Search threads" : "Search chats"}
              className="w-full pl-9 pr-3 py-2 text-sm bg-gray-50 border border-gray-200 rounded-lg outline-none focus:ring-1 focus:ring-[#1F4D3E] focus:border-[#1F4D3E]"
            />
          </div>
        </div>
      </div>

      <div className="flex-1 overflow-y-auto bg-white">
        <div className="p-3">
          <div className="text-xs font-semibold text-gray-500 px-1 mb-2 flex items-center gap-2">
            <MessageSquare size={14} />
            {serverMode ? "Threads" : "Chat history"}
          </div>

          {serverMode ? (
            <>
              {threadsLoading ? (
                <div className="text-sm text-gray-500 p-3 rounded-xl bg-gray-50 border border-gray-200">
                  Loading threads
                </div>
              ) : filteredThreads.length === 0 ? (
                <div className="text-sm text-gray-500 p-3 rounded-xl bg-gray-50 border border-gray-200">
                  No threads yet. Start a chat.
                </div>
              ) : (
                <div className="space-y-2">
                  {filteredThreads.map((t) => {
                    const id = String(t?.id || "");
                    const active = id && id === activeThreadId;
                    const title = String(t?.title || "New conversation");
                    return (
                      <div
                        key={id}
                        className={`w-full p-3 rounded-xl border transition ${
                          active ? "border-[#1F4D3E] bg-green-50/40" : "border-gray-200 bg-white hover:bg-gray-50"
                        }`}
                      >
                        <button
                          type="button"
                          onClick={async () => {
                            await loadThread(id);
                            setSidebarOpen(false);
                          }}
                          className="w-full text-left"
                        >
                          <div className="text-sm font-medium text-gray-900 truncate">
                            {title}
                          </div>
                          <div className="text-xs text-gray-500 truncate mt-0.5">
                            {t?.chat_type ? String(t.chat_type) : "chat"}
                          </div>
                        </button>
                      </div>
                    );
                  })}
                </div>
              )}

              <div className="mt-4 text-[11px] text-gray-500 leading-relaxed">
                This list comes from your threads API. If threads are blocked, the UI falls back to local mode.
              </div>
            </>
          ) : (
            <>
              {filteredSessions.length === 0 ? (
                <div className="text-sm text-gray-500 p-3 rounded-xl bg-gray-50 border border-gray-200">
                  No chats yet. Start one, then it will appear here.
                </div>
              ) : (
                <div className="space-y-2">
                  {filteredSessions.map((s) => {
                    const active = conversationId === s.conversationId;
                    return (
                      <div
                        key={s.conversationId}
                        className={`w-full p-3 rounded-xl border transition ${
                          active ? "border-[#1F4D3E] bg-green-50/40" : "border-gray-200 bg-white hover:bg-gray-50"
                        }`}
                      >
                        <button
                          type="button"
                          onClick={() => openSession(s.conversationId)}
                          className="w-full text-left"
                        >
                          <div className="text-sm font-medium text-gray-900 truncate">
                            {s.title || "New chat"}
                          </div>
                          <div className="text-xs text-gray-500 truncate mt-0.5">
                            {s.lastMessage || "No messages yet"}
                          </div>
                        </button>

                        <div className="mt-2 flex justify-end">
                          <button
                            type="button"
                            onClick={() => {
                              if (confirm("Delete this chat from this browser?")) deleteSession(s.conversationId);
                            }}
                            className="text-xs px-3 py-1.5 rounded-lg border border-gray-200 bg-white hover:bg-gray-50"
                          >
                            Delete
                          </button>
                        </div>
                      </div>
                    );
                  })}
                </div>
              )}

              <div className="mt-4 text-[11px] text-gray-500 leading-relaxed">
                Chats store in this browser. Account sync arrives when registration is live.
              </div>
            </>
          )}
        </div>
      </div>

      <div className="p-3 border-t border-gray-100 bg-white flex justify-between items-center gap-2">
        <button
          type="button"
          onClick={() => setIsCookieModalOpen(true)}
          className="text-xs text-gray-500 hover:underline"
        >
          Cookie preferences
        </button>

        <button
          type="button"
          onClick={copyDirectory}
          className="text-xs text-[#1F4D3E] hover:underline"
          title="Copy"
        >
          {copied ? "Copied" : "Copy directory link"}
        </button>
      </div>
    </div>
  );

  const DesktopSidebar = (
    <div
      className={`hidden md:block h-screen sticky top-0 border-r border-gray-200 bg-white transition-all duration-300 ${
        sidebarOpen ? "w-[320px]" : "w-[64px]"
      }`}
    >
      {sidebarOpen ? (
        SidebarContent
      ) : (
        <div className="h-full flex flex-col items-center py-3">
          <button
            type="button"
            onClick={() => setSidebarOpen(true)}
            className="p-2 rounded-xl border border-gray-200 bg-white hover:bg-gray-50 shadow-sm"
            title="Open sidebar"
          >
            <PanelLeftOpen size={18} className="text-gray-700" />
          </button>

          <div className="mt-3 w-full px-2">
            <button
              type="button"
              onClick={startNewChat}
              className="w-full p-2 rounded-xl bg-[#1F4D3E] text-white hover:bg-[#163C30] flex items-center justify-center"
              title="New chat"
            >
              <Plus size={18} />
            </button>
          </div>

          <div className="mt-auto pb-3">
            <button
              type="button"
              onClick={() => setIsCookieModalOpen(true)}
              className="p-2 rounded-xl border border-gray-200 bg-white hover:bg-gray-50"
              title="Cookie preferences"
            >
              <Menu size={18} className="text-gray-700" />
            </button>
          </div>
        </div>
      )}
    </div>
  );

  const MobileSidebar = (
    <div className="md:hidden">
      <button
        onClick={() => setSidebarOpen(true)}
        className="fixed left-4 top-4 z-50 p-2 rounded-xl bg-white border border-gray-200 shadow-sm"
        title="Open menu"
      >
        <Menu size={18} className="text-gray-700" />
      </button>

      <div className={`fixed inset-0 z-[9998] transition ${sidebarOpen ? "opacity-100" : "opacity-0 pointer-events-none"}`}>
        <div className="absolute inset-0 bg-black/40" onClick={() => setSidebarOpen(false)} />
        <div
          className={`absolute left-0 top-0 h-full w-[320px] bg-white shadow-2xl transition-transform duration-300 ${
            sidebarOpen ? "translate-x-0" : "-translate-x-full"
          }`}
        >
          <div className="absolute right-3 top-3">
            <button onClick={() => setSidebarOpen(false)} className="p-2 rounded-lg text-gray-500 hover:bg-gray-100" title="Close">
              <X size={18} />
            </button>
          </div>
          {SidebarContent}
        </div>
      </div>
    </div>
  );
  return (
    <div className="min-h-screen flex bg-gray-50">
      {!isEmbed && (
        <>
          {DesktopSidebar}
          {MobileSidebar}
        </>
      )}

      <div className={`flex-1 flex flex-col bg-white sm:bg-gray-50 text-gray-900 font-sans ${isEmbed ? "h-screen" : ""}`}>
        <div className="bg-white px-4 sm:px-6 py-4 shadow-sm z-10 border-b border-gray-100 relative">
          <div className="relative h-[44px]">
            <div className="absolute left-1/2 -translate-x-1/2 top-1/2 -translate-y-1/2 text-center pointer-events-none">
              <h1 className="text-[#1F4D3E]" style={{ fontFamily: "var(--font-gilda-display), serif", fontSize: 28, lineHeight: 1 }}>
                {BRAND}
              </h1>
              <h2 className="text-[#1F4D3E] opacity-90" style={{ fontFamily: "var(--font-gilda-display), serif", fontSize: 20 }}>
                {PRODUCT}
              </h2>
            </div>

            <div className="absolute right-0 top-1/2 -translate-y-1/2 flex items-center gap-1">
              <button
                onClick={handleEndChat}
                className="text-gray-400 hover:text-red-500 hover:bg-red-50 rounded-full p-2 transition-all"
                title="End chat"
              >
                <Trash2 size={18} />
              </button>
            </div>
          </div>
        </div>

        <div className="flex-1 overflow-hidden relative w-full">
          <div ref={scrollRef} className="h-full overflow-y-auto px-4 sm:px-6 py-4 space-y-6 scroll-smooth pb-28">
            <div className="w-full max-w-3xl mx-auto space-y-6">
              {messages.map((m, i) => (
                <div
                  key={i}
                  className={`flex w-full ${m.role === "user" ? "justify-end" : "justify-start"}`}
                >
                  {m.role === "assistant" && (
                    <div className="w-8 h-8 rounded-full bg-[#1F4D3E] flex items-center justify-center text-white text-xs mr-2 flex-shrink-0 mt-2 font-serif">
                      5*
                    </div>
                  )}

                  <div
                    className={`max-w-[85%] sm:max-w-[75%] px-6 py-4 text-[15px] sm:text-base leading-relaxed shadow-sm ${
                      m.role === "user"
                        ? "bg-[#1F4D3E] text-white rounded-2xl rounded-br-sm"
                        : "bg-white border border-gray-100 text-gray-800 rounded-2xl rounded-bl-sm"
                    }`}
                  >
                    {m.role === "user" ? (
                      <div className="space-y-2">
                        {editingUserIndex === i ? (
                          <div className="space-y-2">
                            <textarea
                              value={editDraft}
                              onChange={(e) => setEditDraft(e.target.value)}
                              className="w-full bg-white text-gray-900 border border-gray-200 rounded-xl p-3 text-sm outline-none focus:ring-1 focus:ring-[#1F4D3E] focus:border-[#1F4D3E]"
                              rows={3}
                            />
                            <div className="flex justify-end gap-2">
                              <button
                                type="button"
                                onClick={cancelEdit}
                                className="text-xs px-3 py-1.5 rounded-lg border border-gray-200 bg-white hover:bg-gray-50"
                              >
                                Cancel
                              </button>
                              <button
                                type="button"
                                onClick={() => saveEdit(i)}
                                className="text-xs px-3 py-1.5 rounded-lg bg-[#1F4D3E] text-white hover:bg-[#163C30]"
                              >
                                Save
                              </button>
                            </div>
                          </div>
                        ) : (
                          <div className="whitespace-pre-wrap">{m.content}</div>
                        )}

                        {i === lastUserIndex && !loading && editingUserIndex !== i ? (
                          <div className="flex justify-end">
                            <button
                              type="button"
                              onClick={() => beginEdit(i)}
                              className="text-xs px-3 py-1.5 rounded-lg border border-gray-200 bg-white hover:bg-gray-50"
                            >
                              Edit
                            </button>
                          </div>
                        ) : null}
                      </div>
                    ) : (
                      <div className="space-y-2">
                        <FormattedMessage content={m.content} />
                        
                        {/* FOLLOWUPS_RENDER */}
                        {Array.isArray((m as any).suggestions) &&
                        (m as any).suggestions.length > 0 &&
                        i === lastAssistantIndex &&
                        !loading ? (
                          <div className="flex flex-wrap gap-2 pt-2">
                            {(m as any).suggestions.slice(0, 3).map((s: string, k: number) => (
                              <button
                                key={k}
                                type="button"
                                onClick={() => handleSend(s)}
                                className="text-xs px-3 py-1.5 rounded-full border border-gray-200 bg-white hover:bg-gray-50"
                              >
                                {s}
                              </button>
                            ))}
                          </div>
                        ) : null}
{i === lastAssistantIndex && !loading ? (
                          <div className="flex">
                            <button
                              type="button"
                              onClick={handleRegenerate}
                              className="text-xs px-3 py-1.5 rounded-lg border border-gray-200 bg-white hover:bg-gray-50"
                            >
                              Regenerate
                            </button>
                          </div>
                        ) : null}
                      </div>
                    )}
                  </div>
                </div>
              ))}

              {shouldShowLeadCard && (
                <div className="flex justify-start w-full">
                  <div className="w-8 h-8 rounded-full bg-[#1F4D3E] flex items-center justify-center text-white text-xs mr-2 flex-shrink-0 mt-2 font-serif">
                    5*
                  </div>
                  <div className="max-w-[85%] sm:max-w-[75%]">
                    <LeadCaptureInline
                      onSubmit={(name, email) => captureLead(name, email)}
                      onSkip={() => skipLead()}
                    />
                  </div>
                </div>
              )}

              {loading && (
                <div className="flex justify-start w-full">
                  <div className="w-8 h-8 mr-2" />
                  <div className="bg-white border border-gray-100 px-5 py-4 rounded-2xl rounded-bl-sm flex space-x-1 items-center shadow-sm">
                    <div className="text-xs text-gray-500 mr-2">Aura is typing</div>
                    <div className="w-2 h-2 bg-gray-300 rounded-full animate-bounce" />
                    <div className="w-2 h-2 bg-gray-300 rounded-full animate-bounce" />
                    <div className="w-2 h-2 bg-gray-300 rounded-full animate-bounce" />
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>

        <div className="bg-white border-t border-gray-100 p-4 w-full z-20">
          <div className="w-full max-w-3xl mx-auto">
            {!loading && (
              <div className="flex gap-2 overflow-x-auto pb-3 mb-2">
                {quickPrompts.map((prompt, i) => (
                  <button
                    key={i}
                    onClick={() => handleSend(prompt)}
                    className="flex-shrink-0 px-4 py-2 bg-gray-50 hover:bg-gray-100 border border-gray-200 rounded-full text-xs sm:text-sm text-gray-600 hover:text-[#1F4D3E] transition-all whitespace-nowrap flex items-center gap-1.5"
                  >
                    <Sparkles size={12} className="opacity-50" />
                    {prompt}
                  </button>
                ))}
              </div>
            )}

            <div className="relative bg-white border border-gray-300 rounded-[26px] shadow-sm focus-within:ring-2 focus-within:ring-[#1F4D3E] focus-within:border-transparent transition-all">
              <textarea
                ref={textareaRef}
                value={input}
                onChange={(e) => setInput(e.target.value)}
                onKeyDown={handleKeyDown}
                placeholder={`Message ${ASSISTANT}…`}
                className="w-full bg-transparent outline-none resize-none text-[16px] leading-relaxed pl-5 pr-44 py-3 rounded-[26px]"
                rows={1}
                style={{ minHeight: "50px", maxHeight: "180px" }}
              />
              <div className="absolute right-2 bottom-1.5 flex items-center gap-2">
                <VoiceToTextButton onText={(t) => setInput((prev) => (prev ? `${prev} ${t}` : t))} />
                <AuraVoice />
                <button
                  onClick={() => handleSend()}
                  disabled={loading || !input.trim()}
                  className="h-10 w-10 rounded-full flex items-center justify-center bg-[#1F4D3E] text-white shadow-md hover:bg-[#163C30] disabled:opacity-40"
                >
                  <Send size={16} />
                </button>
              </div>
            </div>

            <div className="mt-3 text-xs text-gray-500 flex items-center justify-between gap-2">
              <button
                type="button"
                onClick={copyDirectory}
                className="text-[#1F4D3E] hover:underline"
              >
                {copied ? "Copied" : `Copy ${DIRECTORY_DOMAIN}`}
              </button>

              {serverMode ? (
                <span className="text-gray-400">Thread: {activeThreadId ? "Active" : "None"}</span>
              ) : lead?.email ? (
                <span className="text-gray-400">Saved as {lead.email}</span>
              ) : (
                <span className="text-gray-400">Saving appears after a few replies</span>
              )}
            </div>
          </div>
        </div>

        <CookiePreferenceCenter isOpen={isCookieModalOpen} onClose={() => setIsCookieModalOpen(false)} />
      </div>
    </div>
  );
}
